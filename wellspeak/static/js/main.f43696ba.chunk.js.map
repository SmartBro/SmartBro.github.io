{"version":3,"sources":["BotAvatar/index.js","Chat/Message/index.js","redux/chat.actions.js","services/speechRecognition.js","Chat/index.js","redux/chat.action-creators.js","App.js","serviceWorker.js","services/speechSynthesis.js","services/chatBot.js","redux/chat.reducer.js","redux/middleware/logger.js","redux/configureStore.js","redux/chat.epics.js","index.js"],"names":["BotAvatar","className","src","alt","Message","isYours","text","wrapperClass","classNames","messageClass","recognition","window","SpeechRecognition","webkitSpeechRecognition","interimResults","lang","start","addEventListener","event","transcript","Array","from","results","map","result","join","interimResultHandlers","forEach","handler","isFinal","resultHandlers","subscribe","handleResult","handleInterimResult","push","isFunction","length","unsubscribe","handlerId","splice","mapDispatchToProps","startSpeaking","type","stopSpeaking","transcription","payload","connect","state","isSpeaking","isBotAnswering","messages","useEffect","message","index","key","App","Boolean","location","hostname","match","SpeechSynthesisUtterance","messageQueue","speechSynthesis","engVoices","this","getVoices","filter","voice","includes","find","voiceURI","speak","unshift","speaking","aTalkUrl","initialState","isError","isSpeechLoading","logger","store","next","action","console","group","info","log","getState","groupEnd","rootEpic","combineEpics","action$","pipe","ofType","tap","mergeMap","input","ajax","url","encodeURI","method","headers","response","responses","catchError","error","of","CHAT_ACTIONS","epicMiddlware","createEpicMiddleware","enhancer","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","applyMiddleware","createStore","run","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f43696ba.chunk.js","sourcesContent":["import React from 'react';\n\nexport function BotAvatar({ className }) {\n    return (\n        <div className={className}>\n            <h2>Wellspeak Bot</h2>\n            <img src=\"female_avatar.svg\" alt=\"female avatar\"/>\n        </div>\n    );\n}\n\nexport default BotAvatar;\n","import React from 'react';\nimport classNames from 'classnames';\nimport './message.css';\n\nexport function Message({ className, isYours, text }) {\n    const wrapperClass = classNames('message-wrapper', { 'message-yours': isYours });\n    const messageClass = classNames('message', className);\n    return (\n        <div className={wrapperClass}>\n            <div className={messageClass}>\n                {text}\n            </div>\n        </div>\n    );\n}\n\nexport default Message;\n","export const SPEAK_START = 'SPEAK_START';\nexport const SPEAK_END = 'SPEAK_END';\nexport const VOICE_RECOGNITION_REQUESTED = 'VOICE_RECOGNITION_REQUESTED';\nexport const VOICE_RECOGNITION_SUCCESS = 'VOICE_RECOGNITION_SUCCESS';\nexport const VOICE_RECOGNITION_FAIL = 'VOICE_RECOGNITION_FAIL';\nexport const BOT_RESPONSE_VOICE_START = 'BOT_RESPONSE_VOICE_START';\nexport const BOT_RESPONSE_VOICE_END = 'BOT_RESPONSE_VOICE_END';\nexport const BOT_RESPONSE_REQUESTED = 'BOT_RESPONSE_REQUESTED';\nexport const BOT_RESPONSE_SUCCESS = 'BOT_RESPONSE_SUCCESS';\nexport const BOT_RESPONSE_FAIL = 'BOT_RESPONSE_FAIL';\n\nexport default {\n    SPEAK_START,\n    SPEAK_END,\n    VOICE_RECOGNITION_REQUESTED,\n    VOICE_RECOGNITION_SUCCESS,\n    VOICE_RECOGNITION_FAIL,\n    BOT_RESPONSE_VOICE_START,\n    BOT_RESPONSE_VOICE_END,\n    BOT_RESPONSE_REQUESTED,\n    BOT_RESPONSE_SUCCESS,\n    BOT_RESPONSE_FAIL,\n};\n","import { isFunction } from \"rxjs/internal-compatibility\";\n\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nexport const recognition = new SpeechRecognition();\nrecognition.interimResults = true;\nrecognition.lang = 'en-US';\n\nrecognition.start();\nrecognition.addEventListener('result', handleRecognition);\nrecognition.addEventListener('end', recognition.start);\n\nconst resultHandlers = [];\nconst interimResultHandlers = [];\n\nexport const subscribe = (handleResult, handleInterimResult) => {\n    resultHandlers.push(handleResult);\n    if (isFunction(handleInterimResult)) {\n        interimResultHandlers.push(handleInterimResult);\n    }\n\n    return resultHandlers.length - 1;\n};\n\nexport const unsubscribe = handlerId => {\n    resultHandlers.splice(handlerId, 1);\n};\n\nfunction handleRecognition(event) {\n    const transcript = Array.from(event.results)\n        .map(result => result[0])\n        .map(result => result.transcript)\n        .join('');\n\n    interimResultHandlers.forEach(handler => handler(transcript));\n\n    if (event.results[0].isFinal) {\n        resultHandlers.forEach(handler => handler(transcript));\n    }\n}\n","import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport './chat.css'\nimport { Message } from \"./Message\";\nimport { startSpeaking, stopSpeaking } from \"../redux/chat.action-creators\";\nimport { subscribe, unsubscribe } from \"../services/speechRecognition\";\n\nconst mapStateToProps = state => ({\n    isSpeaking: state.isSpeaking,\n    isBotAnswering: state.isBotAnswering,\n    messages: state.messages\n});\nconst mapDispatchToProps = { startSpeaking, stopSpeaking };\n\nfunction Chat({ className, isSpeaking, isBotAnswering, messages, startSpeaking, stopSpeaking }) {\n    useEffect(() => {\n        startSpeaking();\n\n        const handlerId = subscribe(transcription => {\n            stopSpeaking(transcription);\n        });\n\n        return () => unsubscribe(handlerId);\n    });\n\n    return (\n        <div className={className}>\n            {messages.map((message, index) => <Message isYours={message.isYours} text={message.text} key={index}/>)}\n            {isBotAnswering ? <Message isYours={false} text='...'/> : ''}\n            {isSpeaking ? <Message isYours={true} text='...'/> : ''}\n        </div>\n    );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Chat);\n","import { SPEAK_END, SPEAK_START } from \"./chat.actions\";\n\nexport const startSpeaking = () => ({ type: SPEAK_START });\nexport const stopSpeaking = (transcription) => ({ type: SPEAK_END, payload: transcription });\n","import React from 'react';\nimport './App.css';\nimport { BotAvatar } from './BotAvatar';\nimport Chat from \"./Chat\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <BotAvatar className=\"avatar-box\" />\n        <Chat className=\"chat-box\" />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","const message = new SpeechSynthesisUtterance();\nconst messageQueue = [];\n\nspeechSynthesis.addEventListener('voiceschanged', selectVoice);\nmessage.addEventListener('end', speakNext)\n\nfunction selectVoice() {\n    const voices = this.getVoices() || [];\n    const engVoices = voices.filter(voice => voice.lang.includes('en'));\n    message.voice = engVoices.find(voice => voice.voiceURI === 'Samantha') || engVoices[0];\n}\n\nexport const speak = (text = '') => {\n    if (speechSynthesis.speaking) {\n        messageQueue.push(text);\n        return;\n    }\n    message.text = text;\n    speechSynthesis.speak(message);\n};\n\nfunction speakNext() {\n    if (messageQueue.length) {\n        speak(messageQueue.unshift());\n    }\n}\n","import { ajax } from \"rxjs/ajax\";\n\nconst pandaRobotsApi = 'https://api.pandorabots.com';\nconst botKey = 'I0Nu18SASdsfw0QbgPN91ykXwFPPoc2-SCjfp1sAd-ZS7RueYFzHNIJ31_52M6ZjdaDTwGMnxsU~';\nconst aTalkUrl = `${pandaRobotsApi}/atalk?botkey=${botKey}`;\n\nexport const talk = (input) => ajax({\n    url: `${aTalkUrl}&input=${encodeURI(input)}`,\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n    }\n});\n","import {\n    BOT_RESPONSE_FAIL,\n    BOT_RESPONSE_REQUESTED,\n    BOT_RESPONSE_SUCCESS,\n    SPEAK_END,\n    SPEAK_START,\n    VOICE_RECOGNITION_FAIL,\n    VOICE_RECOGNITION_REQUESTED,\n    VOICE_RECOGNITION_SUCCESS\n} from './chat.actions';\n\nconst initialState = {\n    isError: false,\n    isSpeaking: false,\n    isSpeechLoading: false,\n    isBotAnswering: false,\n    messages: [],\n};\n\nexport const chatReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case SPEAK_START:\n            return { ...state, isSpeaking: true };\n        case SPEAK_END:\n            return {\n                ...state,\n                isSpeaking: false,\n                messages: [ ...state.messages, { isYours: true, text: action.payload }]\n            };\n        case VOICE_RECOGNITION_REQUESTED:\n            return { ...state, isSpeechLoading: true };\n        case VOICE_RECOGNITION_SUCCESS:\n            return { ...state, isSpeechLoading: false, isError: false };\n        case VOICE_RECOGNITION_FAIL:\n            return { ...state, isSpeechLoading: false, isError: true };\n        case BOT_RESPONSE_REQUESTED:\n            return { ...state, isBotAnswering: true };\n        case BOT_RESPONSE_SUCCESS:\n            return {\n                ...state,\n                isBotAnswering: false,\n                isError: false,\n                messages: [ ...state.messages, { isYours: false, text: action.payload }]\n            };\n        case BOT_RESPONSE_FAIL:\n            return { ...state, isBotAnswering: false, isError: true };\n        default:\n            return state;\n    }\n};","const logger = store => next => action => {\n    console.group(action.type);\n    console.info('dispatching', action);\n    const result = next(action);\n    console.log('next state', store.getState());\n    console.groupEnd();\n    return result;\n};\n\nexport default logger;\n","import { createStore, applyMiddleware, compose } from 'redux';\nimport {combineEpics, createEpicMiddleware} from 'redux-observable';\nimport { botResponseEpic, botSpeechEpic, speechEpic } from './chat.epics';\nimport { chatReducer } from \"./chat.reducer\";\nimport logger from \"./middleware/logger\";\n\nconst rootEpic = combineEpics(\n    botSpeechEpic,\n    botResponseEpic,\n    speechEpic\n);\n\nconst epicMiddlware = createEpicMiddleware();\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst enhancer = composeEnhancers(applyMiddleware(logger, epicMiddlware));\n\nexport const store = createStore(chatReducer, enhancer);\n\nepicMiddlware.run(rootEpic);\n","import CHAT_ACTIONS, {\n    BOT_RESPONSE_FAIL,\n    BOT_RESPONSE_REQUESTED,\n    BOT_RESPONSE_SUCCESS, SPEAK_START\n} from './chat.actions';\nimport { ofType } from \"redux-observable\";\nimport { catchError, map, mergeMap, tap } from \"rxjs/operators\";\nimport { of } from \"rxjs\";\nimport { speak } from \"../services/speechSynthesis\";\nimport { talk } from \"../services/chatBot\";\n\nexport const speechEpic = action$ => action$.pipe(\n    ofType(CHAT_ACTIONS.SPEAK_END),\n    map(action => ({ type: CHAT_ACTIONS.BOT_RESPONSE_REQUESTED, payload: action.payload }))\n);\n\nexport const botResponseEpic = action$ => action$.pipe(\n    ofType(BOT_RESPONSE_REQUESTED),\n    mergeMap(action =>\n        talk(action.payload)\n            .pipe(\n                map(({ response }) => {\n                    return { type: BOT_RESPONSE_SUCCESS, payload: response.responses.join(' ') };\n                }),\n                catchError(error => of({ type: BOT_RESPONSE_FAIL, error }))\n            )\n    )\n);\n\nexport const botSpeechEpic = action$ => action$.pipe(\n    ofType(BOT_RESPONSE_SUCCESS),\n    tap(action => speak(action.payload)),\n    map(() => ({ type: SPEAK_START }))\n);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { store } from \"./redux/configureStore\";\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}